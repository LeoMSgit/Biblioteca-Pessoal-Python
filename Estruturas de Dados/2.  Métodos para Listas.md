# 1) Defini√ß√£o
- Em Python, m√©todos s√£o fun√ß√µes caracter√≠sticas de um certo objeto e s√£o utilizadas para realizar opera√ß√µes nesse objeto. No caso de listas, os m√©todos s√£o usados para modificar, buscar, ordenar ou manipular os elementos dentro delas
- Os m√©todos de listas s√£o chamados utilizando a sintaxe de ponto (.)
- No geral, os m√©todos n√£o s√£o universais para todas as estruturas de dados em Python
  - Cada estrutura tem um conjunto espec√≠fico de opera√ß√µes baseado em sua organiza√ß√£o e mutabilidade, por√©m alguns podem ser usados em v√°rias estruturas

# 2) Adicionar Elementos
## 2.1) .append(elemento)
- Adiciona um `elemento` ao final da lista
  - Ao adicionar uma `string`, ela ser√° adicionada como um √∫nico elemento
  - Caso outra lista seja adicionada com .append, ela ser√° adicionada como uma lista aninhada, mas seus elementos n√£o ser√£o inseridos diretamente na lista principal
  
```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
lista.append(6)  
print(lista)  
# Sa√≠da: ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5, 6]
```
```python
lista = [1, 2, 3]
lista.append([4, 5])
print(lista)  # Sa√≠da: [1, 2, 3, [4, 5]] 
```

## 2.2) .insert(index, elemento)
- Insere um elemento `elemento` em uma posi√ß√£o `index` espec√≠fica e "empurra" os outros elementos para a pr√≥xima posi√ß√£o
  - Caso seja utilizado um `index` maior do que o tamanho da lista, o Python n√£o gerar√° erro, em vez disso, o elemento ser√° adicionado ao final da lista, como se tiv√©ssemos usado `.append(elemento)`

```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
lista.insert(3, "X")  
print(lista)  
# Sa√≠da: ["P", "y", "t", "X", "h", "o", "n", 1, 2, 3, 4, 5]
```
Aqui o elemento `X` √© inserido na pois√ß√£o `3`, os outros elementos posteriores s√£o movidos em uma posi√ß√£o


## 2.3) .extend(nova_lista)
- Concatena/Adiciona outra lista a sua lista original
  - Ao passar uma string, ela ser√° dividida em caracteres pois ser√° considerada uma nova lista
  - Diferentemente do set(lista), .extend **N√ÉO** remove as duplicatas, ele ir√° apenas juntar uma lista no final da outra
 
```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
nova_lista = [4, 5, 7, 8]
lista.extend(nova_lista)  
print(lista)  
# Sa√≠da: ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5, 4, 5, 7, 8]
```

Aqui a lista `nova_lista` √© "colada" ao final da lista original, resultando em `[..., 4, 5, 4, 5, 7, 8]`

```python
lista = [1, 2, 3]
lista.extend("abc")
print(lista)  # Sa√≠da: [1, 2, 3, 'a', 'b', 'c'] 
```

# 3) Remover Elementos 
## 3.1) .remove(elemento)
- Remove a primeira ocorr√™ncia do elemento na lista
  - Para remover **TODOS** os elementos desejados da lista, √© necess√°rio criar um loop utilizando `while`

```python
lista = ["P", "y", "t", "h", "o", "o", "o", "n", 1, 2, 3, 4, 5]
lista.remove("o")  
print(lista)  
# Sa√≠da: ["P", "y", "t", "h", "o", "o", "n", 1, 2, 3, 4, 5]
```
Aqui apenas a primeira ocorr√™ncia do elemento `"o"` foi removida

<br/>
<br/>
<br/>

```python
lista = [1, 2, 3, 4, 2, 5, 2, 6, 2, 7]
valor_remover = 2

while valor_remover in lista:
    lista.remove(valor_remover)

print(lista)
# Sa√≠da: [1, 3, 4, 5, 6, 7]
```
Aqui o loop `while` continuar√° a remover o elemento `2`, at√© que ele n√£o seja mais encontrado na lista

## 3.2) .pop() ou .pop(index)
- Por padr√£o, remove o `√∫ltimo` elemento da lista. Por√©m pode utilizar um `index` para escolher uma posi√ß√£o para ser eliminada

```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
lista.pop()  
print(lista)  
# Sa√≠da: ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4]
```
Aqui o elemento `5`, na √∫ltima posi√ß√£o, foi removido da lista
<br/>
<br/>
<br/>

```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
lista.pop(2)  
print(lista)  
# Sa√≠da: ["P", "y", "h", "o", "n", 1, 2, 3, 4, 5]
```
Aqui o elemento `"t"`, na posi√ß√£o 2, foi removido da lista

## 3.3) .clear()
- Remove completamante **TODOS** os elementos da lista, deixando-a vazia,mas mantendo a refer√™ncia √† lista original
```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
lista.clear()
print(lista)
# Sa√≠da: []
```

# 4) Ordena√ß√£o e Revers√£o
## 4.1) .reverse()
- Inverte a posi√ß√£o dos elementos na lista sem ordenar
  - `.reverse()`, inverte a pr√≥pria lista e n√£o pode ser usado como par√¢metro para criar uma nova lista, ao inv√©s disso podemos utilizar o slicing `lista[::-1]`
```python
lista = [5, 2, 9, 1, 7]
lista.reverse()
print(lista)
# Sa√≠da: [7, 1, 9, 2, 5]
```
```python
lista = [1, 2, 3]
nova_lista = lista[::-1]   # Cria uma nova lista invertida
print(nova_lista)          # Sa√≠da: [3, 2, 1]
print(lista)               # Sa√≠da: [1, 2, 3]     (original permanece inalterada)
```

## 4.2) .sort()
- Ordena os elementos da lista de forma crescente, funciona tanto para n√∫meros quanto para palavras (baseado na tabela ASCII)
  - Ao tentar ordenar listas mistas (strings e n√∫meros) ocorrer√° um `TypeError`

```python
lista = [5, 2, 9, 1, 7]
lista.sort()
print(lista)
# Sa√≠da: [1, 2, 5, 7, 9]
```
```python
lista = ["banana", "abacaxi", "uva", "laranja"]
lista.sort()
print(lista)  
# Sa√≠da: ['abacaxi', 'banana', 'laranja', 'uva']
```

### 4.2.1) üõë Problema com Case-Sensitive
- Mai√∫sculas v√™m antes das min√∫sculas, segundo a ordem da tabela ASCII
  - Para evitar o problema das mai√∫sculas e min√∫sculas, podemos passar par√¢metros especiais `".sort(key=str.lower)"`
```python
lista = ["Banana", "abacaxi", "Uva", "laranja"]
lista.sort()
print(lista)
# Sa√≠da: ['Banana', 'Uva', 'abacaxi', 'laranja']  # Mai√∫sculas antes de min√∫sculas
```
```python
lista.sort(key=str.lower)
print(lista)
# Sa√≠da: ['abacaxi', 'Banana', 'laranja', 'Uva']
```

## 4.3) .sort(reverse=True)
- Ao passar o par√¢mtro `reverse=True`, o m√©todo `.sort` ordena os elementos da lista de forma decrescente

```python
lista = [5, 2, 9, 1, 7]
lista.sort(reverse=True)
print(lista)
# Sa√≠da: [9, 7, 5, 2, 1]
```
```python
lista = ["banana", "abacaxi", "uva", "laranja"]
lista.sort(reverse=True)
print(lista)  
# Sa√≠da: ['uva', 'laranja', 'banana', 'abacaxi']
```

# 5) Pesquisa e Contagem
## 5.1) .index(elemento)
- Retorna a posi√ß√£o da primeira ocorr√™ncia de um `elemento` na lista na forma de uma nova vari√°vel
  - Similiarmente ao `.remove()`, para obter **TODOS** as posi√ß√µes de certo `elemento` na lista, √© necess√°rio criar um loop
```python
lista = ["P", "y", "t", "h", "o", "n", 1, 2, 3, 4, 5]
posicao_elemento = lista.index("y")
print(posicao_elemento)
# Sa√≠da: 1
```
```python
lista = [1, 2, 3, 2, 4, 2, 5, 6, 2]
valor_procurado = 2
posicoes = []

for i in range(len(lista)):
    if lista[i] == valor_procurado:
        posicoes.append(i)

print(posicoes)
# Sa√≠da: [1, 3, 5, 8]
```
Aqui a cada passagem do loop, um `elemento` ser√° comparado com a vari√°vel `valor_procurado`, caso ele seja igual, sua posi√ß√£o ser√° adicionada com `.append()` a uma nova lista, resultando na lista `posicoes = [1, 3, 5, 8]`

## 5.1) .count(elemento)
- Conta quantas vezes `elemento` aparece na lista
- Faz diferencia√ß√£o entre mai√∫sculas e min√∫sculas, pois a compara√ß√£o em Python √© case-sensitive
  - Para contar todas as varia√ß√µes independentemente de mai√∫sculas e min√∫sculas, √© necess√°rio modificar os elementos usando lower(), diferentemente do `.sort()`,  `.count()` n√£o aceita um argumento `key`

```python
lista = [1, 2, 3, 1, 2, 1, 4, 5]
contagem = numeros.count(1)
print(contagem)
# Sa√≠da: 3 (o n√∫mero 1 aparece tr√™s vezes)
```

```python
lista = ["Python", "python", "PYTHON", "PyThOn", "python"]
print(lista.count("python"))
# Sa√≠da: 2
```
```python
lista = ["Python", "python", "PYTHON", "PyThOn", "python"]
valor_procurado = "python"
contagem = sum(1 for elemento in lista if elemento.lower() == valor_procurado.lower())

print(contagem)
# Sa√≠da: 5
```
Aqui utilizando Compreens√£o de Listas contamos todas as ocorr√™ncias ignorando mai√∫sculas e min√∫sculas


# 6) C√≥pia
## 6.1) copy()
- Cria uma c√≥pia independente da lista, ou seja, altera√ß√µes na c√≥pia n√£o afetam a lista original
```python
lista_original = [1, 2, 3]
lista_copia = lista_original.copy()

lista_copia.append(4)  
print(lista_original)  # Sa√≠da: [1, 2, 3] (original permanece inalterada)
print(lista_copia)  # Sa√≠da: [1, 2, 3, 4] (c√≥pia foi modificada)
```

### 6.1.1) üõë Problema com = (Atribui√ß√£o direta)
- Quando utilizamos `lista_b = lista_a`, n√£o estamos criando uma c√≥pia da lista, em vez disso, `lista_b` apenas aponta para a mesma lista na mem√≥ria. Isso significa que qualquer altera√ß√£o em `lista_b` tamb√©m afetar√° `lista_a`

```python
lista_a = [1, 2, 3]
lista_b = lista_a  # Atribui√ß√£o direta

lista_b.append(4)  # Alteramos lista_b

print(lista_a)  # Sa√≠da: [1, 2, 3, 4]  ‚ùå A lista original tamb√©m foi alterada!
print(lista_b)  # Sa√≠da: [1, 2, 3, 4]
```
### 6.1.2) üõë Problema com Listas Aninhadas 
- Se a lista for aninhada (ou seja, contiver outras listas dentro), `.copy()` copia apenas a lista principal, mas as listas internas ainda s√£o compartilhadas entre `lista_a` e `lista_b`
  - Nesse caso precisamos importar a biblioteca `copy` e utilizar `deepcopy()`

```python
lista_b = copy.deepcopy(lista_a)
lista_b[0].append(99)

print(lista_a)  # Sa√≠da: [[1, 2, 3], [4, 5, 6]]      (original permanece inalterada)
print(lista_b)  # Sa√≠da: [[1, 2, 3, 99], [4, 5, 6]]  (c√≥pia foi modificada)
```
